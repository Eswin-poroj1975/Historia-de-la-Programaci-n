Antes de hablar de lenguajes de programaciÃ³n, pensemos enÂ **quÃ© es un lenguaje**. Un lenguaje lo usamos entre humanos para comunicarnos, expresar nuestros sentimientos, o incluso de forma colaborativa para llegar a un fin. UnÂ **lenguaje natural**Â se define como elÂ **estilo y modo de hablar y escribir de cada persona en particular.**
Ahora, nosotros usamos unÂ **lenguaje de programaciÃ³n**Â para comunicarnos con una computadora y darle instrucciones, cÃ³mo ejecutarlas, a travÃ©s de quÃ© recursos, etc. Algunos lenguajes permiten ser muy especÃ­ficos con las instrucciones. En general, un lenguaje de programaciÃ³n esÂ **un formalismo artificial en el cual los algoritmos pueden ser expresados**.

## Niveles de descripciÃ³n de un lenguaje

Tanto el lenguaje natural como los lenguajes de programaciÃ³n tienen 3 niveles de descripciÃ³n. Los lenguajes de programaciÃ³n tienen un cuarto nivel, del cual hablaremos mÃ¡s en detalle. Estos niveles de descripciÃ³n son:

### GramÃ¡tica/sintaxis

Responde aÂ **Â¿QuÃ© oraciones son las correctas?**Â Analiza como estÃ¡n estructuradas las oraciones, palabras/tokens, para que el intÃ©rprete (humano o mÃ¡quina) las pueda entender correctamente. Permite formar frases propias del lenguaje (la gramÃ¡tica/sintaxis no es igual en el EspaÃ±ol, el InglÃ©s, o en Python).

### SemÃ¡ntica

Responde aÂ **Â¿QuÃ© significa una oraciÃ³n correcta?**Â Indica que es lo que queremos hacer con esa oraciÃ³n. En programaciÃ³n son los ciclos, las variables, etc. Una vez que hemos comprobado que estÃ¡ correctamente escrita, vemos si lo que estÃ¡ escrito es una operaciÃ³n correcta. Por ejemplo: no podemos dividir dos frases, pero si podemos unirlas.

### PragmÃ¡tica

Responde alÂ **Â¿CÃ³mo utilizamos una oraciÃ³n significativa?**Â Una oraciÃ³n significativa es aquella que tiene un significado interpretable. Debemos ser cuidadosos con la pragmÃ¡tica, especialmente en la programaciÃ³n. Las instrucciones que le damos a una computadora no pueden ser tan ambiguas como las que podrÃ­amos dar en lenguaje natural.

![Ejemplo de pragmÃ¡tica](https://static.platzi.com/media/articlases/Images/2022-04-23%20%2825%29.png)

### ImplementaciÃ³n

Es un nivel de descripciÃ³n exclusivo de los lenguajes de programaciÃ³n. Se trata de la forma en que se transforman instrucciones en acciones, especÃ­ficamente mediante el cÃ³digo que escribimos.

## Resumen

Viendo los 4 niveles de descripciÃ³n como una receta de cocina, laÂ **sintaxis**Â serÃ­an las frases correctas para expresar la receta, laÂ **semÃ¡ntica**Â se refiere a quÃ© es una receta en particular, laÂ **pragmÃ¡tica**Â es cÃ³mo un chef interpreta la receta, y laÂ **implementaciÃ³n**Â es la forma en que la receta utiliza los ingredientes.
#estudio_platzi #historia_programacion

>Un paradigma de programaciÃ³n, es la forma en que clasificamos un lenguaje por sus caracteristicas o un estilo de programacion basado en la forma en que aborda un programa y/o las herramientas que utiliza para resolver un problema

Existe una gran cantidad de paradigmas. Sin embargo, todos derivan de 3 paradigmas principales:Â **imperativo**,Â **declarativo**Â yÂ **dirigido por eventos**Â (este Ãºltimo se verÃ¡ en una prÃ³xima clase).

---
# Cuales son los principales paradigmas de programaciÃ³n
## ProgramaciÃ³n imperativa

Se trata de expresar cÃ³mo debe solucionarse un problema paso a paso. Es el paradigma mÃ¡s utilizado. Se encuentra en lenguajes como Fortran, Java, C, Python, Ruby, etc. De Ã©l se derivan paradigmas como laÂ **programaciÃ³n orientada a objetos**Â oÂ **procedimental**.  
![ProgramaciÃ³n imperativa en C](https://static.platzi.com/media/articlases/Images/2022-04-24.png)

## ProgramaciÃ³n declarativa

La programaciÃ³n declarativa consiste en expresar quÃ© problema debe solucionarse, sin especificar cÃ³mo hacerlo. Se enfoca en el resultado, y en reducir o evitar los efectos colaterales. Algunos lenguajes en este paradigma son LISP, Haskell, Prolog, SQL, Elixir, XPath, etc. De la programaciÃ³n reactiva se derivan paradigmas como elÂ **funcional**, elÂ **lÃ³gico**,Â **reactivo**Â oÂ **matemÃ¡tico**.  
![ProgramaciÃ³n en Haskell declarativa](https://static.platzi.com/media/articlases/Images/2022-04-24%20%281%29.png)

--- 
![[Pasted image 20231205221928.png]]
 > Woh, no sabÃ­a cÃ³mo funcionaba Haskell jaja, algo curioso y MindBlow es que CSS es un lenguaje declarativo tambiÃ©n porque se enfoca en el resultado, de hecho CSS es un lenguaje de queryâ€™s porque usas selectores.  
 > 
 > Y si hablamos de queryâ€™s y lenguajes declarativos, tambiÃ©n estÃ¡ SQL, ya que se enfoca en quÃ© es lo que quieres obtener, no en cÃ³mo lo vas a obtener.
 > 
 > Jajaja es simple, a un lenguaje declarativo solo le dices quÃ© quieres hacer, por ejemplo, con CSS tÃº le dices: â€œSeleccioname este elemento y ponle estos estilosâ€, y CSS lo harÃ¡, Â¿cÃ³mo lo harÃ¡? Eso no importa porque es un lenguaje declarativo ğŸ˜„

---
# MÃ¡quina abstracta: flujo de datos en computadoras digitales conceptuales
UnaÂ **mÃ¡quina abstracta**Â es una computadora digital que ejecutaÂ **algoritmos**, los cuales estÃ¡n formalizados para que la mÃ¡quina entienda. Se trata de una mÃ¡quina abstracta porque estamos aislando las caracterÃ­sticas de una computadora para llevarlas a este concepto.

## Estructura de una mÃ¡quina abstracta

La estructura general de una mÃ¡quina abstracta consiste en:

- Una memoria donde almacena datos y sus programas.
- Un intÃ©rprete del lenguaje de programaciÃ³n que maneja las secuencias de control del programa, controla la transferencia de datos y ademÃ¡s maneja su memoria.
- Unas operaciones que nos darÃ¡n un resultado que serÃ¡ la instrucciÃ³n que deseamos.  
    ![Estructura de una mÃ¡quina abstracta](https://static.platzi.com/media/articlases/Images/2022-04-23%20%2823%29.png)

### Operaciones de una mÃ¡quina abstracta

Una mÃ¡quina abstracta puede realizar operaciones para:

- **Procesar datos primitivos**: Un dato primitivo es aquel con el que un lenguaje de programaciÃ³n trabaja de forma nativa. Puede tener datos primitivos de tipo entero, flotante, booleanos, etc. Ojo, los datos primitivos de un lenguaje, no son necesariamente primitivos en otro.
- **Controlar secuencia de ejecuciÃ³n de operaciones**: La mÃ¡quina abstracta no solo serÃ¡ capaz de llevar la secuencia de operaciones, tambiÃ©n estructuras de control y condicionales comoÂ `If`,Â `Else`. PodrÃ¡ usar ciclos comoÂ `While`,Â `For`, etc.
- **Controla transferencia de datos**: Esto quiere decir que la informaciÃ³n puede pasar de las instrucciones a una estructura de dato y viceversa. Con tal de que la informaciÃ³n pueda ser utilizada para sus procesamientos.
- **Manejo de memoria**: La mÃ¡quina abstracta usa este recurso para almacenar los datos que se derivan de las operaciones de los programas o incluso, almacenar informaciÃ³n que le indiquemos.

## Ciclo de ejecuciÃ³n

El ciclo de ejecuciÃ³n se refiere aÂ **los pasos que toma una mÃ¡quina abstracta para ejecutar operaciones**.

1. Inicia el programa.
2. Se traen las instrucciones a travÃ©s del intÃ©rprete del lenguaje de programaciÃ³n, el cual decodifica las instrucciones.
3. Trae sus operandos para realizar las operaciones.
4. Elige que operaciÃ³n va a ejecutar segÃºn las instrucciones.
5. Ejecuta las operaciones indicadas. Una o varias. Incluso la instrucciÃ³n detener el programa.
6. Si se ejecuta detener, el programa se termina. En caso contrario, se guardan los resultados y se regresa al segundo paso.

![Ciclo de ejecuciÃ³n de una mÃ¡quina abstracta](https://static.platzi.com/media/articlases/Images/2022-04-23%20%2824%29.png)

### MÃ¡quina de Turing:

Es un ejemplo de mÃ¡quina abstracta. LaÂ **MÃ¡quina de Turing**Â tiene 2 cintas en cada lado, y en el centro tiene un dispositivo lector-escritor, es capaz de leer o escribir sobre Ã©l mismo. En los rodillos hay instrucciones, indicadas con nÃºmeros 1 y 0. Puede indicar que escriba, lea, etc. En un sentido abstracto, podemos entender que la maquina de Turing realiza los procesos que vimos antes.

## ConclusiÃ³n

LaÂ **mÃ¡quina abstracta**Â es un concepto que nos ayuda a entender como funcionan las computadoras y los lenguajes de programaciÃ³n en general. UnaÂ **mÃ¡quina abstracta**Â es capaz de realizar operaciones complejas si la equipamos para ello.

---
# ProgramaciÃ³n dirigida por eventos
LaÂ **programaciÃ³n dirigida por eventos**Â se caracteriza por no controlar la secuencia de ejecuciones. MÃ¡s bien, en laÂ **programaciÃ³n dirigida por eventos**Â se reacciona a los sucesos ocurridos. Para ello, generalmente los programas corren indefinidamente integrando manejadores de eventos (**event handlers**).

## Eventos y event handler

Los programas dirigidos a eventos se mantienen en estado de reposo, hasta que una acciÃ³n dispara unÂ **event handler**. Este se encarga de procesar el evento en cuestiÃ³n. Algunos eventos comunes son:

- Clics (ya sea en un mouse, teclado, pantalla, etc.)
- Sensores (de temperatura, movimiento, etc.)
- Mensajes
- Triggers
- Casos de aplicaciÃ³n
- Solicitudes HTTP

## Casos de uso

Entre los casos de uso de la programaciÃ³n dirigida a eventos encontramos.

- GUIs
- Aplicaciones web
- Sistemas de booking
- Sistemas de alarmas
- RobÃ³tica
- Videojuegos

## Funcionamiento

En la programaciÃ³n imperativa tenemos una secuencia de pasos que se van a ejecutar de manera secuencial, y despuÃ©s puede repetirse el ciclo o puede llegar a detenerse el programa porque asÃ­ lo decidimos o porque forzamos su detenciÃ³n.

Por otro lado, en laÂ **programaciÃ³n dirigida por eventos**, tenemos unÂ **ciclo**Â el cual mientras haya una condiciÃ³n que sea verdadera, se puede estar ejecutando de manera indefinida. Este ciclo va a escuchar ciertos eventos que van a modificar algunas variables de estado (por ejemplo, el contador de vidas en un videojuego). La modificaciÃ³n de estas variables puede resultar en que el ciclo se detenga, y que el programa finalice.

## Lenguajes y ejemplos

Algunos lenguajes que implementan este paradigma son:

- Java
- JavaScript
- C#
- LibrerÃ­as/Frameworks de GUI
    - JavaFX, React.js, PyQT
- PrÃ¡cticamente, cualquier lenguaje orientado a objetos.

AquÃ­ vemos un ejemplo en JavaScript. Nota el uso deÂ **addEventListener**  
![Ejemplo en JavaScript](https://static.platzi.com/media/articlases/Images/2022-04-26%20%283%29.png)

Y un ejemplo en Java. AÃ±adimos un event listener conÂ **addMouseListener**

![Ejemplo en Java](https://static.platzi.com/media/articlases/Images/2022-04-26%20%284%29.png)

## ConclusiÃ³n

La programaciÃ³n dirigida por eventos nos permite tener programas que corran indefinidamente, y que respondan cuando ocurre un evento. Deja en los comentarios si consideras que la programaciÃ³n orientada a eventos es un paradigma imperativo o declarativo ğŸ˜‰.

---
# ProgramaciÃ³n Estructurada
LaÂ **programaciÃ³n estructurada**Â apareciÃ³ como soluciÃ³n a la programaciÃ³n con escritura secuencial, la cual era muy difÃ­cil y costosa de leer, mantener y modificar. LaÂ **programaciÃ³n estructurada**Â nace con laÂ **arquitectura de Von Neuman**, la cual reconoce que tanto los programas como los datos que estos arrojan pueden guardarse en memoria.

![Arquitectura de Von Neumann](https://static.platzi.com/media/articlases/Images/2022-04-24%20%282%29.png)

A partir de la arquitectura de Von Neumann se crean lasÂ **estructuras de control**, que son la base de la programaciÃ³n estructurada. Con la apariciÃ³n de las estructuras de control se redujo la necesidad de usar la expresiÃ³nÂ **â€œGOTOâ€**, que se refiere a llamar una lÃ­nea de cÃ³digo cualquiera desde otra lÃ­nea de cÃ³digo. A continuaciÃ³n vemos un ejemplo de un diagrama de flujo estructurado que implementa laÂ [serie de Fibonacci](https://platzi.com/clases/2397-python-profesional/39532-la-sucesion-de-fibonacci/).  
![Fibonacci](https://static.platzi.com/media/articlases/Images/2022-04-24%20%283%29.png)

Algunos de los primeros lenguajes que implementaron la programaciÃ³n estructurada son FORTRAN, Pascal, COBOL, ADA, Perl y C.

## CaracterÃ­sticas de la programaciÃ³n estructurada

La programaciÃ³n estructurada se caracteriza por el uso de estructuras de control (condicionales y ciclos). Otras caracterÃ­sticas de la programaciÃ³n estructurada (y de los lenguajes imperativos en general) son:

- Uso de entradas/salidas (input y output, oÂ **I/O**)
- Manejo deÂ **errores y excepciones**.
- AbstracciÃ³n de procedimientos.
- Expresiones y asignaciÃ³n.
- Soporte para estructuras de datos.

---
## CÃ³digo de Fibonacci
```C++
#include <iostream>
using namespace std;

int main(){
	int n, fib0 = 0, fib1 = 1, c, i;
	
	cout << "Interacion de Fibonacchi" << endl;
	cout << "Ingrese el numero n" << endl;
	cin >> n;
	
	for(i=1; i<=n; i++){
		cout << fib0 << " ";
		c = fib0 + fib1;
		fib0 = fib1;
		fib1 = c;
	}
	return 0;
}
```

---
# ProgramaciÃ³n Funcional

>Woow, todo esto fue lo que me preguntaron en mi primera entrevista tÃ©cnica para ser software engineer en MÃ©xico. Fue tipo asÃ­  
-QuÃ© es una clase?  
Es la definicÃ³n de un objeto ğŸ˜ƒ  
-y quÃ© es un objeto?  
Es una instancia de una clase, es como si una clase fuera un cortador de galleta y el objeto es una galleta  
-y quÃ© es una instancia?  
Los objetos se almacenan en memoria y la instancia es el espacio que hace referencia a ellos  
-muy bien, ahora cuentame quÃ© es el polimorfismo?  
-â€¦  
-no te preocupes, dime quÃ© es el encapsulamiento?  
-el encapsulamiento permite limitar ? los mÃ©todos de un objeto?  
-okâ€¦ y quÃ© es lamnda?  
-â€¦una letra griega :v  
Estudie informatica y me sentia super confiada, la verdad con estas clases y las entrevistas tÃ©nicas me doy cuenta del gap mental que tenia entre cada concepto.

---

La programaciÃ³n funcional es un paradigma declarativo que usaÂ **funciones**Â como â€œ**ciudadanas de primera clase**â€. Las funciones (en programaciÃ³n) son fragmentos de cÃ³digo reutilizables, que pueden recibir datos y dar salidas a otros datos como resultado, incluyendo otras funciones. Mediante la programaciÃ³n funcional se busca eliminar o reducir losÂ **efectos secundarios**.

En la programaciÃ³n funcional se pueden crearÂ **funciones de orden superior (HOF)**. Prioriza el uso deÂ **recursividad**Â yÂ **HOF**Â para resolver problemas.

## Origen de la programaciÃ³n funcional

En los aÃ±os 30, Alonzo Church desarrollÃ³ el cÃ¡lculoÂ **Lambda**. Alan Turing demostrÃ³ que este es equivalente a las mÃ¡quinas de Turing. A finales de los 50, se desarrollÃ³Â **LISP**, implementando la notaciÃ³nÂ **lambda**Â de Church. AquÃ­ un ejemplo en LISP de cÃ³mo se ve unÂ _â€œhola mundoâ€_Â y una funciÃ³n recursiva (que se llama a sÃ­ misma) donde se calcula elÂ [factorial](https://platzi.com/clases/2884-notacion-matematica/47332-sumatoria-y-factorial/)Â de un nÃºmeroÂ `n`.

```lisp
(print "Hello, World!")
(defun factorial (n)
    (if (= n 0) 1
        (* n (factorial (- n 1)))))
```

## Funciones

En matemÃ¡ticas, una funciÃ³n se define como una relaciÃ³n entre dos conjuntos que asigna cada elemento del primero, un elemento del segundo o ninguno.  
Por ejemplo, una funciÃ³n que toma un valor â€œXâ€ y genera un valor â€œYâ€.

```
f(X) = X + 3
f(X) = X^2 + 3
```

Un ejemplo de funciones en Python es el siguiente. La funciÃ³n suma recibe dos nÃºmeros (a y b) y retorna la suma de los dos nÃºmeros. AquÃ­ podemos ver que el concepto de funciÃ³n en matemÃ¡ticas y en programaciÃ³n es parecido.

```python
def suma (a, b):
    return a + b
operacion_1 = suma(3, 2)
```

Las funciones tambiÃ©n pueden hacer uso de otras funciones, como en el siguiente ejemplo.

```python
def es_par(x):
    return not es_impar(x)
```

Es mÃ¡s, las funciones pueden llamarse a sÃ­ mismas (recursiÃ³n)

```python
def fibonacci(n):
    if n<=1:
        return m
    else:
        return fibonacci(n-1)+fibonacci(n-2)
```

## Conceptos de la programaciÃ³n funcional

Al principio mencionamos conceptos comoÂ **â€œciudadanas de primera claseâ€**,Â **funciones de orden superior**Â yÂ **efectos secundarios**. Definamos estos (y mÃ¡s) conceptos.

### Funciones como ciudadanas de primera clase

El que las funciones seanÂ **ciudadanas de primera clase**Â implica que son reconocidas como un tipo de dato mÃ¡s. Esto hace que se puedan usar en cualquier parte del programa.

### Funciones de orden superior

Una funciÃ³n de orden superior puede recibir una o varias funciones como parÃ¡metro. AdemÃ¡s, puede retornar otra funciÃ³n.

### Funciones puras

Una funciÃ³n es pura si cumple con los siguientes requisitos.

- **Es determinista**: para un parÃ¡metro, la funciÃ³n siempre va a retornar el mismo resultado siempre y cuando no se cambie dicho parÃ¡metro (por ejemplo, una funciÃ³n que retorne un valor aleatorio no es determinista).
- Un valor de entrada da un solo valor de salida.
- No genera efectos secundarios.
- No incluye funciones impuras.

### Funciones lambda

Una funciÃ³nÂ **lambda**Â es una funciÃ³n anÃ³nima, es decir, que no se le asigna un nombre. Normalmente, se usan en una Ãºnica secciÃ³n del cÃ³digo. Por lo general realizan operaciones simples.

Un ejemplo de una funciÃ³n lambda que multiplica dos nÃºmeros en Python:

```python
x = lambda a, b: a**b
print(x(3,3))
```

### Efectos secundarios (side effects)

Es comÃºn escuchar deÂ **efectos secundarios**Â cuando hablamos de programaciÃ³n imperativa. Lo podemos ver cuando manejamos funciones o variables de contexto global o que estÃ¡n delimitadas. Cuando escribimos cÃ³digo sabemos que lo que estÃ¡ dentro de una funciÃ³n, no afecta a otra, si es que usamos la sintaxis correcta. Pero tambiÃ©n existen funciones que usan parÃ¡metros o que tienen alcance global y pueden tener efectos secundarios.

Los efectos secundarios son cambios observables en partes de un programa como:

- El estado de la aplicaciÃ³n.
- Valores de datos.
- ModificaciÃ³n de archivos.

## Lenguajes y ejemplos

Este es un ejemplo en Haskell, donde calculamos el factorial de un nÃºmero. En ejemplos anteriores habÃ­amos podido ver como se define el tipo de dato, despuÃ©s se asignan los tipos de valores y se empieza a llamar a la funciÃ³n. Podemos ver que el cÃ³digo no es tan amplio como si lo hubiÃ©ramos escrito de forma no recursiva con otros lenguajes.

```haskell
module Main where

import Text.Printf

factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n factorial (n - 1)

line x = printf "%d! = %d\n" x $
factorial x

main = mapM_ line [0..16]
```

AquÃ­ otro ejemplo conÂ **F#**, donde vemos que tambiÃ©n es recursivo porque la funciÃ³n factorial se llama a sÃ­ misma.

```haskell
let rec factorial n = 
    match n with
    | 0 | 1 -> 1
    | _ -> n * factorial(n-1)
```

Otros lenguajes funcionales son SCHEME, CLOJURE, RACKET y ERLANG.

## ConclusiÃ³n

La programaciÃ³n funcional nos permite escribir cÃ³digo especificando quÃ© queremos hacer mÃ¡s que cÃ³mo se debe hacer. A su vez, nos permite evitar efectos secundarios. Es importante entender conceptos comoÂ **funciones de orden superior**,Â **recursividad**Â oÂ **funciones puras**Â para poder hacer un buen uso de la programaciÃ³n funcional.

---
# ProgramaciÃ³n LÃ³gica
La programaciÃ³n lÃ³gicaÂ **es un paradigma declarativo que expresa los objetivos como una colecciÃ³n de afirmaciones o reglas acerca de los resultados y restricciones en lÃ³gica matemÃ¡tica**. Entre sus Ã¡reas de aplicaciÃ³n encontramos el NLP (Procesamiento de lenguaje natural), la recuperaciÃ³n de informaciÃ³n en bases de datos y aplicaciones matemÃ¡ticas.

## ClÃ¡usulas de Horn

La programaciÃ³n lÃ³gica se basa en lasÂ **ClÃ¡usulas de Horn**. Estas son preposiciones definidas por predicados, donde tenemos unÂ **hecho**Â (algo que damos por sentado) y tenemos uno o varios predicados. Lo correcto serÃ­a tener por lo menos 2, para poder determinar si algo es verdadero o falso, tambiÃ©n se les conoce como cuerpo/body. Las clÃ¡usulas de Horn estÃ¡n relacionadas con lasÂ [tablas de verdad](https://www.youtube.com/watch?v=Pfyuv5ZnNNw).  
![ClÃ¡usula de horn](https://static.platzi.com/media/user_upload/1-9eec6a3e-8472-4216-b214-02e4be6bd1a0.jpg)

H= Hecho/Head of the rule.  
P= Predicado/Body

### Ejemplo de clÃ¡usula de Horn

Podemos decir que es verdadero que estÃ¡ nevando en la ciudad, C es el nombre de la ciudad. Si estÃ¡ lloviendo y hace frÃ­o, entonces es verdadero que estÃ¡ nevando. Y, por el contrario, si quisiÃ©ramos negar que estÃ¡ lloviendo, pero hace frÃ­o, entonces es falso que estÃ¡ nevando. Esto tiene una estrecha relaciÃ³n con las tablas de verdad.

```prolog
nevando(C) â† lluvia(C), frÃ­o(C)
```

## Origen de la programaciÃ³n lÃ³gica

La programaciÃ³n lÃ³gica viene de los aÃ±os 60, cuando Cordell Green propuso el uso de clÃ¡usulas en programas a finales de los 60. El lenguajeÂ **Prolog**Â impulsÃ³ este paradigma. Otros lenguajes lÃ³gicos son Alf, Fril ,Mercury, Oz ,Visual Prolog y XSB.

No es muy frecuente el uso de programaciÃ³n lÃ³gica en la industria. Se usa mÃ¡s en investigaciÃ³n y Ã¡mbitos acadÃ©micos.

### Ejemplos de Prolog

Este es un ejemplo deÂ _â€œhola mundoâ€_Â en Prolog. NÃ³tese que al final se imprimeÂ **true**.

```prolog
% Hola mundo

?- write('Hello World!'), nl
> Hello World!
> true
```

En el siguiente ejemplo vemos como le indicamos que hay personas que hablan un lenguaje, hacemos la evaluaciÃ³n de la persona 1 con la persona 2 y cuÃ¡l es el resultado. Luego hacemos tambiÃ©n la evaluaciÃ³n, preguntando â€œQuiÃ©n habla francÃ©sâ€ El resultado retornado deberÃ­a ser â€œJuanâ€.

```prolog
speaks(juan, french)
speaks(isabel, english)
speaks(eduadro, french)
speaks(eduardo, english)

talkswith(Person1, Person2) :-
speaks(Person1, L),
speaks(Person2, L),
Person1 \= Person2

?- speaks(Who, French)
```

## ConclusiÃ³n

La programaciÃ³n lÃ³gica es un paradigma utilizado sobre todo en entornos acadÃ©micos. Se basa en el uso de ClÃ¡usulas de Horn, y tiene una relaciÃ³n estrecha con las tablas de verdad.

>ğŸ’¡ LaÂ **programaciÃ³n lÃ³gica**Â permite resolver problemas medianteÂ **predicados**, este es usado en laÂ **Inteligencia Artificial**.

---
# ProgramaciÃ³n Orientada a Objetos (POO)
La programaciÃ³nÂ **orientada a objetos (POO)**Â se basa en el concepto deÂ **objeto**. Un objeto es una abstracciÃ³n de una entidad que posee datos en forma deÂ **propiedades o atributos**, y procedimientos en forma deÂ **mÃ©todos**. Por ejemplo, si vemos a un humano como un objeto, un humano tieneÂ **propiedades**Â como su altura o color de cabello, asÃ­ comoÂ **mÃ©todos**Â como leer, escribir, comer, etc.

El primer lenguaje orientado a objetos fueÂ **Simula**. Otros lenguajes orientados a objetos son C++, C#, PHP, Ruby, Python, etc.

## Conceptos principales de la POO

Ya hablamos del concepto deÂ **objeto**. Ahora introducimos otros conceptos fundamentales dentro de la programaciÃ³n orientada a objetos.

### Clases

UnaÂ **clase**Â es un molde o fÃ¡brica de objetos. En una clase seÂ **definen**Â las propiedades y mÃ©todos que pueden tener un objeto. Se dice queÂ **un objeto es una instancia de una clase**. Cuando se crea un objeto a partir de una clase, se definen los valores de las propiedades del objeto.

### Propiedades

Las propiedades son caracterÃ­sticas que distinguen un tipo de objeto de otro, pero que varÃ­an entre objetos. Por ejemplo, los objetos de tipo humano pueden tener distintos colores de cabello, pero la propiedad â€œcolor de cabelloâ€ es una que existe en todos los humanosÂ ~~(en los calvos esta propiedad valdrÃ­a null)~~.

### MÃ©todos

Los mÃ©todos son acciones o procedimientos que puede llevar a cabo un objeto. Por ejemplo, si un profesor fuera un objeto, un mÃ©todo del profesor serÃ­a â€œdar claseâ€.

## Pilares de la POO

La programaciÃ³n orientada a objetos se fundamenta en 4 pilares. Es importante entender estos pilares, ya que la POO es el paradigma mÃ¡s utilizado dentro del desarrollo de software.

### AbstracciÃ³n

La abstracciÃ³n se refiere a aislar las caracterÃ­sticas de un objeto. Se trata de conceptualizar objetos y cuÃ¡les son sus caracterÃ­sticas

### Herencia

La herencia permite que una claseÂ **herede**Â propiedades y mÃ©todos de otra clase. Por ejemplo, la claseÂ _â€œperroâ€_Â hereda de la claseÂ _â€œanimalâ€_. En este caso dirÃ­amos que la claseÂ _â€œperroâ€_Â es hija de la claseÂ _â€œanimalâ€_.

### Encapsulamiento

El encapsulamiento ayuda a aislar parte del cÃ³digo de una instancia. Esto permite que cuando sea llamada no altere su estado por accidente o por efecto colateral de los mÃ©todos o comportamientos de otros objetos con los que puede interactuar.

### Polimorfismo

ElÂ [polimorfismo](https://platzi.com/clases/2034-php-poo/32133-polimorfismo/)Â significa que ante los mensajes o llamados que reciba una clase o una instancia los va a interpretar de una forma distinta a como lo harÃ­an clases o instancias distintas.

## Ventajas y desventajas de la POO

Como cualquier paradigma de programaciÃ³n, la POO presenta varios pros y contras.

### Ventajas

- CÃ³digo reutilizable.
- ReducciÃ³n de redundancia.
- FÃ¡cil de mantener.
- Seguridad (mediante mÃ©todos, propiedades y clases privadas/protegidas).

### Desventajas

- TamaÃ±o (cuando una clase es muy general y tiene muchas clases hijas)
- Esfuerzo (por la especificidad que requieren)
- Velocidad del desarrollo (por el esfuerzo)

## ConclusiÃ³n

La programaciÃ³n orientada a objetos es el paradigma mÃ¡s utilizado gracias a que permite reutilizar el cÃ³digo de una manera segura y fÃ¡cil. Es fundamental entender los conceptos y pilares de la programaciÃ³n orientada a objetos.

---
# ProgramaciÃ³n por Procedimientos
LaÂ **programaciÃ³n procedural**Â oÂ **procedimental**Â se deriva de laÂ **programaciÃ³n estructurada**. Consiste en dividir el cÃ³digo en secciones lÃ³gicas llamadas rutinas oÂ **procedimientos**, donde cada procedimiento resuelve una tarea especÃ­fica, y se ejecuta cada vez que sea necesario. Cabe destacar que un procedimiento puede llamar a otros procedimientos. Algunos de los primeros lenguajes procedurales son FORTRAN, ALGOL, COBOL Y BASIC.

![Flujo de un programa procedural](https://static.platzi.com/media/articlases/Images/2022-04-24%20%284%29.png)

## ComparaciÃ³n con la programaciÃ³n orientada a objetos

Hay algunas similitudes entre laÂ **programaciÃ³n procedural**Â y laÂ **orientada a objetos**Â (tema de la siguiente clase).

![ComparaciÃ³n entre procedural y POO](https://static.platzi.com/media/articlases/Images/2022-04-24%20%286%29.png)

---
# Paradigmas de la ProgramaciÃ³n
UnÂ **paradigma**Â es una teorÃ­a o conjunto de teorÃ­as cuyo nÃºcleo central se acepta sin cuestionar y que suministra la base y modelo para resolver problemas y avanzar en conocimiento.

## Paradigmas en programaciÃ³n
En programaciÃ³n, cuando hablamos de paradigmas, podemos hablar deÂ **cÃ³mo se clasifican los lenguajes basados en sus caracterÃ­sticas**. TambiÃ©n podemos referirnos aÂ **estilos de programaciÃ³n**, es decir, a cÃ³mo se aborda un problema o quÃ© herramientas se utilizan. 

> **En general, que un lenguaje tenga un paradigma especÃ­fico significa que limita o prohÃ­be ciertas acciones.**

### Paradigmas y lenguajes de programaciÃ³n

Podemos clasificar los lenguajes de programaciÃ³n en funciÃ³n de su paradigma.

**Paradigmas puros**: lenguajes como Smalltalk que esÂ **POO**Â o Haskell que solo esÂ **funcional**  
**Multiparadigma**: lenguajes como Python, Ruby, Scala, PHP, etc.

### DiscusiÃ³n

Cabe preguntarnos, Â¿es correcto etiquetar asÃ­ a los lenguajes, o el estilo de programaciÃ³n de alguien? Â¿CÃ³mo afectan los paradigmas a los modelos de programaciÃ³n y patrones de diseÃ±o?

---
Â > UnÂ **paradigma de programaciÃ³n**Â es una forma o estilo deÂ **programaciÃ³n de software**.

---
# ProgramaciÃ³n Concurrente
Imagina que trabajas en una panaderÃ­a. Mientras se calienta el horno, estÃ¡s cortando masa, preparando panes, y una vez que se hornean, al sacarlos hay que esperar a que se enfrÃ­en y despuÃ©s colocar una cobertura de chocolate. TÃº intentarÃ¡s optimizar los recursos. Mientras el horno se estÃ¡ calentando, debes preparar mÃ¡s masa, para que asÃ­, cuando termine, inmediatamente metes el otro lote de masa.

TambiÃ©n puedes contratar a una persona que te ayude. Divides las tareas, ejecutando elÂ **paralelismo**, que es dividir las tareas entre los recursos disponibles (siempre y cuando puedan dividirse).

## Concurrencia

LaÂ **concurrencia**Â ocurre cuando hay una serie de peticiones a un mismo recurso que puede ser limitado, y se atienden esas peticiones de forma parcial o totalmente desordenada. Una analogÃ­a Ãºtil para entender puede ser la panaderÃ­a. Imagina que tu panaderÃ­a empieza a crecer, porque es bastante concurrida y los clientes empiezan a acumularse.

## Concurrencia vs. paralelismo

En laÂ **concurrencia**Â tenemos una serie de peticiones con un solo recurso limitado para atenderlas. Cabe preguntarse Â¿cuÃ¡l serÃ­a el orden y la prioridad en la que se atienden las peticiones? Por otro lado, en elÂ **paralelismo**Â tenemos recursos divididos que pueden atender las peticiones al mismo tiempo sin ningÃºn problema. ElÂ **paralelismo**Â y laÂ **concurrencia**Â son conceptos diferentes, pero que van de la mano.

## Secuencia vs. Concurrencia

En unaÂ **secuencia**Â tenemos los pasos A, B, C, D. Y estos serÃ¡n atendidos en el orden que se hizo la peticiÃ³n. En cambio, enÂ **concurrencia**Â podemos iniciar en el proceso A, saltar al D, luego al C, completar el A y despuÃ©s pasar al Ãºltimo proceso. Todo esto se hace mediante losÂ [hilos](https://platzi.com/clases/1441-ruby/15856-concurrencia-vs-paralelismo-threads-en-ruby/)Â de unÂ **proceso**.

### Estados de un hilo

UnÂ **hilo**Â tiene 5 estados posibles

- **Creado**: no estÃ¡ listo para correr.
- **Ejecutable/Listo**: espera para ejecutarse.
- **Ejecutando**: se ejecuta en el procesador.
- **Bloqueado**: espera a entrar al cÃ³digo que requiere acceso al recurso compartido o abandona el procesador.
- **Terminado**: se ha detenido y no puede reiniciarse.

### SecciÃ³n crÃ­tica del hilo

Es una secciÃ³n de cÃ³digo que requiere acceso exclusivo a una variable compartida. Sucede cuando varios hilos debenÂ **â€œcomunicarse entre sÃ­ para decidir cuÃ¡l va a tener acceso al recurso en el momentoâ€**. Esta secciÃ³n crÃ­tica causa distintos problemas al usar concurrencia, los cuales exploraremos en la prÃ³xima clase.

---
# Problemas de la ProgramaciÃ³n Concurrente
La programaciÃ³n concurrente se basa en el uso deÂ **hilos**. Cuando tenemos varios hilos compartiendo recursos entre sÃ­ se pueden presentar algunos problemas, entre ellos:

## Carreras (race conditions)

LosÂ **race conditions**Â ocurren cuando dos o mÃ¡s hilos desean acceder a un recurso lo mÃ¡s pronto posible. Por ejemplo, tenemos una variable C inicializada en 0, pero despuÃ©s en alguna parte del cÃ³digo a C se le asigna el valor de C + 1. Entonces un hilo llegarÃ¡ primero y al ver que vale 0, le agregarÃ¡ el valor de 1, almacena ese dato y ahora C vale 1.

Pero si otro hilo llega despuÃ©s, pensarÃ¡ que C vale 1, entonces aÃ±adirÃ¡ otro 1, almacenarÃ¡ ese dato y entonces C vale 2. Esto puede ser un problema en un sistema automatizado de dosificaciÃ³n de medicamentos. SÃ­ el sistema es concurrente, Â¿Entonces que harÃ¡? Â¿Le darÃ¡ una dosis o dos dosis? Â¿CÃ³mo se resuelve?.

## Puntos muertos (deadlock)

UnÂ **deadlock**Â ocurre cuando un hilo espera por un evento que nunca sucederÃ¡. Para que suceda unÂ **deadlock**Â deben de cumplirse 4 condiciones:

- Los hilos deben tener acceso exclusivo a los recursos.
- Los hilos deben contener algunos recursos mientras esperan otros.
- Los recursos no se pueden eliminar de los hilos en espera.
- Existe una cadena circular de hilos en las que cada uno contiene uno o mÃ¡s recursos del siguiente hilo.

## Problema de los filÃ³sofos

ElÂ **problema de los filÃ³sofos**Â plantea que hay una mesa redonda con 5 filÃ³sofos conversando. Frente a ellos hay un plato de comida, y hay un palillo chino a la derecha y otro a la izquierda (5 palillos en total). Para comer se necesitan dos palillos chinos, eso significa que no todos podrÃ¡n comer al mismo tiempo.

Hay muchas formas de abordar el problema, pero esas soluciones pueden dar otros problemas. PodrÃ­a ser un sistema de turnos, pero entonces algunos se quedarÃ­an esperando hasta que la comida estÃ© frÃ­a.

## Estrategias para evitar los deadlocks

Dos estrategias para evitar que se cumpla alguna de las condiciones que producen deadlocks son el uso deÂ **semÃ¡foros**Â oÂ **monitores**.

- **SemÃ¡foros**: FuncionarÃ­an como una variable de tipo entero, asociado a un mecanismo de cola de hilos. Si el semÃ¡foro toma valores de â€œ0â€ y â€œ1â€, es binario. En caso contrario, es un â€œsemÃ¡foro contadorâ€.
- **Monitores**: Estructuras de datos abstractas basados en los monitores o kernel de los S.O. Los monitores tienen 4 componentes principales:
    - **InicializaciÃ³n**: contiene cÃ³digo a ser ejecutado.
    - **Datos privados**: procedimientos que se utilizan desde dentro del monitor.
    - **MÃ©todos del monitor**: procedimientos que se pueden llamar desde fuera.
    - **Cola de entrada**: hilos que llaman a algÃºn mÃ©todo del monitor, pero no tienen permiso para ejecutarse aÃºn.

## Algunos lenguajes que implementan concurrencia

Estos lenguajes pueden hacer uso de la concurrencia, aunque de forma distinta entre ellos.

- JavaScript
- C#
- Golang
- Rust
- Elixir
- Haskell

## ConclusiÃ³n

La programaciÃ³n concurrente nos ayuda a ejecutar procedimientos de manera mÃ¡s eficiente en algunos casos, al no ejecutarlos de manera secuencial. Sin embargo, la programaciÃ³n concurrente trae una serie de problemas como las race conditions y deadlocks, para los cuales hay distintas estrategias que ayudan a evitarlos.

---
# DÃ©cada de los 40: primeras computadoras y lenguajes ensambladores
Ya que conoces conceptos sobre paradigmas de programaciÃ³n, es buen momento para conocer la historia y cronologÃ­a de algunos lenguajes de programaciÃ³n, empezando por los aÃ±os 40.

## Primeras computadoras

La primera computadora no fue una mÃ¡quina abstracta, eso es un concepto teÃ³rico. Sin embargo, sabÃ­amos que las computadoras Ã©pocas atrÃ¡s, tenÃ­an tamaÃ±os enormes, ocupaban canchas de tenis y trabajaban con switches. Hay distintos criterios para definir cuÃ¡l fue la primer computadora y algunos autores mencionan que fue laÂ **EDSAC**, que contÃ³ con las siguientes caracterÃ­sticas

- Era electrÃ³nica y digital.
- Realizaba 4 operaciones bÃ¡sicas.
- Era programable.
- Almacenaba programas y datos.

Las precursoras de laÂ **EDSAC**Â carecÃ­an de herramientas lingÃ¼Ã­sticas para ser programadas al nivel de laÂ **EDSAC**. Estas iniciaron conÂ **cÃ³digo mÃ¡quina**, llamadosÂ **first-generation languages (1GL)**.

## Lenguajes ensambladores

LosÂ **lenguajes ensambladores**Â son representaciones simbÃ³licas del lenguaje mÃ¡quina. Un programaÂ **â€œensambladorâ€**Â traduce las instrucciones a cÃ³digo mÃ¡quina. Cada mÃ¡quina tenÃ­a su propio lenguaje, habÃ­a nula portabilidad. Son llamadosÂ **second-generation languages (2GL)**

---
# DÃ©cada de los 50: Fortran y Algol
En la DÃ©cada de los 40. Aparecieron los primeros lenguajes para comunicarnos con las mÃ¡quinas, pero tenÃ­an ciertas limitaciones tÃ©cnicas.

Entonces en los 50 aparecieron los primeros lenguajes de alto nivel (conocidos como trhid generation languages, o 3GL), que se caracterizan por ignorar las limitaciones del hardware y manejar el concepto de portabilidad. A partir de estos lenguajes nacieron otros que veremos en las prÃ³ximas clases, peroâ€¦

## Â¿Por quÃ© hay tantos lenguajes de programaciÃ³n?

Hoy en dÃ­a, a diferencia de los 50, vemos una gran variedad en lenguajes de programaciÃ³n. Y es que hay lenguajes que cumplen distintos propÃ³sitos, ya sea:

- PropÃ³sitos netamente comerciales
- Aplicaciones especÃ­ficas
- Nuevas metodologÃ­as de trabajo
- Implementaciones como desarrollador
- Usar nuevos paradigmas

Muchos lenguajes mÃ¡s modernos son descendientes de los lenguajes de los 50.

## Lenguajes de programaciÃ³n de los 50

Entre los lenguajes mÃ¡s conocidos desarrollados en esta dÃ©cada encontramos

### Fortran (1957)

Desarrollado por IBM y John Backus, el principal uso de FORTRAN era en trabajos numÃ©ricos y cientÃ­ficos, en la mÃ¡quina IBM 704. Es un lenguaje utilizado (en menor medida) hoy en dÃ­a. Sus versiones actuales implementan las estructuras de control, funciones, memoria dinÃ¡mica, comentarios y sub-rutinas. A continuaciÃ³n podemos ver un ejemplo de cÃ³digo en FORTRAN.

>Buenas, como dato les dejo que FORTRAN (que corrijo un pequeÃ±o detalle del profe jaja) proviene de FORmula TRANslation - TraducciÃ³n de FÃ³rmulas y justamente se llamaba asÃ­ porque se habÃ­a creado para programaciÃ³n numÃ©rica/cientÃ­fica, tambiÃ©n para aplicaciones en la fÃ­sica o la ingenierÃ­a. Saludos!

![Fortran code](https://static.platzi.com/media/articlases/Images/2022-04-27%20%281%29.png)

### ALGOL (1958-1960)

**ALGOL**Â es una familia de lenguajes que hace uso de notaciones matemÃ¡ticas, gramÃ¡ticas generativas y estructuras de control. AquÃ­ vemos un ejemplo deÂ **ALGOL**.  
![ALGOL ejemplo](https://static.platzi.com/media/articlases/Images/2022-04-27%20%282%29.png)

---
# DÃ©cada de los 60: LISP, COBOL, Simula
Es natural que despuÃ©s de los 50 se crearan nuevos lenguajes de programaciÃ³n para nuevas mÃ¡quinas. Entre los lenguajes mÃ¡s destacados de la dÃ©cada de los 60 encontramos:

## LISP (List Processor)

**LISP**Â fue el primer lenguaje de aplicaciÃ³n no-numÃ©rica. Se utilizaba para traducciÃ³n automÃ¡tica de textos. HacÃ­a uso deÂ **â€œexpresiones Sâ€**. Cabe destacar que LISP introdujo el concepto de programaciÃ³n de orden superior, y podÃ­a usar memoria dinÃ¡mica.

HabÃ­a distintas variantes de LISP para distintas mÃ¡quinas (LISP Machines), por lo que no era un lenguaje muy portable. Algunos dialectos comunes de LISP sonÂ **Racket**,Â **Common Lisp**,Â **Scheme**Â yÂ **Clojure**.

![Factorial recursivo en LISP](https://static.platzi.com/media/articlases/Images/2022-04-28.png)

## COBOL

**COBOL**Â es acrÃ³nimo deÂ **Common Business Oriented Language**. En un lenguaje imperativo y procedural, (hoy en dÃ­a) orientado a objetos, y que buscaba acercarse lo mÃ¡s posible al inglÃ©s. Cabe destacar que Grace Hopper liderÃ³ el equipo que lo revisÃ³ y lo volviÃ³ un estÃ¡ndar. Un programa deÂ [COBOL](https://platzi.com/cursos/cobol/)Â se divide en 4 secciones:

- **Procedimiento**: cÃ³digo de aspectos algorÃ­tmicos.
- **Datos**: descripciÃ³n de los datos.
- **Ambiente**: especificaciÃ³n del ambiente externo al programa indicado por la mÃ¡quina fÃ­sica.
- **IdentificaciÃ³n**: datos del programa, autor, etc.

![MultiplicaciÃ³n de 3 nÃºmeros en COBOL](https://static.platzi.com/media/articlases/Images/2022-04-28%20%281%29.png)

## SIMULA

**SIMULA**Â es un lenguaje descendiente deÂ **ALGOL**. EstÃ¡ diseÃ±ado para cÃ¡lculo de simulaciones de colas. Se destaca por introducir las clases, objetos, sub-tipos y el mÃ©todo dinÃ¡mico de despacho. MarcÃ³ un antes y un despuÃ©s en los paradigmas, y fue predecesor para Smalltalk y C++ (lenguajes orientados a objetos). Se encuentran trabajos hasta el 2000 en este lenguaje. A continuaciÃ³n vemos un â€œhola mundoâ€ en SIMULA.

![Hola mundo en SIMULA](https://static.platzi.com/media/articlases/Images/2022-04-28%20%282%29%281%29.png)

AquÃ­ vemos la implementaciÃ³n de una clase en SIMULA  
![2022-04-28 (3).png](https://static.platzi.com/media/articlases/Images/2022-04-28%20%283%29.png).

---
# DÃ©cada de los 70: C, Pascal, Smalltalk, Prolog
Gracias a la llegada de los microprocesadores surgieron nuevos lenguajes de programaciÃ³n que se adaptaron a la nueva arquitectura. Las mÃ¡quinas se volvieron mÃ¡s pequeÃ±as y veloces. AdemÃ¡s, gracias a los microprocesadores, se abriÃ³ la posibilidad de la portabilidad (que un mismo lenguaje sirva para distintas mÃ¡quinas). Entre los lenguajes mÃ¡s destacados de esta dÃ©cada encontramos:

## C

**C**Â es un lenguaje de programaciÃ³n de propÃ³sito general. Originalmente desarrollado por Dennis Ritchie entre 1969 y 1972 en los Laboratorios Bell, tiene su nombre como evoluciÃ³n del anterior lenguaje B (a su vez basado en BCPL). Estaba originalmente pensado para el sistema operativo UNIX.

Se trata de un lenguaje de tipos de datos estÃ¡ticos, dÃ©bilmente tipado, de medio nivel. Dispone de las estructuras tÃ­picas de los lenguajes de alto nivel, pero tambiÃ©n de construcciones del lenguaje que permiten un control a bajo nivel.

Por ser de relativamente bajo nivel y tener un modesto conjunto de caracterÃ­sticas, se pueden desarrollar compiladores deÂ [C](https://platzi.com/cursos/lenguaje-c/)Â fÃ¡cilmente. En consecuencia, el lenguaje C estÃ¡ disponible en variedad de plataformas. A continuaciÃ³n un ejemplo en C.

![Factorial en C](https://static.platzi.com/media/articlases/Images/2022-04-28%20%284%29.png)

## Lenguaje Pascal

**Pascal**Â es un lenguaje de programaciÃ³n creado por el profesor suizo Niklaus Wirth entre los aÃ±os 1968 y 1969, y publicado en 1970. Su objetivo era crear un lenguaje que facilitara el aprendizaje de programaciÃ³n a sus alumnos, utilizando la programaciÃ³n estructurada y estructuraciÃ³n de datos.

Pascal fue el lenguaje primario de alto nivel utilizado para el desarrollo en el Apple Lisa, y en los primeros aÃ±os del Macintosh.

Se caracteriza por ser un lenguaje de programaciÃ³n fuertemente tipado, pero que permite la definiciÃ³n de nuevos tipos de datos con elÂ **primitivo type**. AdemÃ¡s, introdujo el cÃ³digo intermedio. Es decir, el cÃ³digo Pascal se compila a un formato llamado â€œ**P-code**â€, que despuÃ©s es interpretado (similar a como funciona laÂ [Java Virtual Machine](https://platzi.com/clases/2245-kotlin/36586-que-es-la-java-virtual-machine/)). AquÃ­ un ejemplo de cÃ³mo calcular el factorial en Pascal.

![Factorial en Pascal](https://static.platzi.com/media/articlases/Images/2022-04-28%20%285%29.png)

## Smalltalk

Los orÃ­genes deÂ **Smalltalk**Â se encuentran en las investigaciones realizadas por Alan Kay, Dan Ingalls, Ted Kaehler, Adele Goldberg y otros durante los aÃ±os 70 en elÂ _Palo Alto Research Center_. Es un lenguaje reflexivo de programaciÃ³n, 100% orientado a objetos y con tipado dinÃ¡mico. Se caracterizÃ³ por incluir los objetos de manera primitiva (es decir, no hay que traer paquetes o librerÃ­as).

Smalltalk manejÃ³ conceptos como las clases, el encapsulamiento, los mÃ©todos pÃºblicos y las instancias privadas. AdemÃ¡s, Smalltalk apuntaba a ser no solo un lenguaje sino un entorno completo de programaciÃ³n. A continuaciÃ³n vemos un ejemplo de cÃ³mo se crea una clase en Smalltalk.  
![Clase en Smalltalk](https://static.platzi.com/media/articlases/Images/2022-04-28%20%286%29.png)

## Meta Language (ML)

DiseÃ±ado por Robin Milner y su equipo a mitad de los 70,Â **ML**Â era utilizado principalmente para manipular informaciÃ³n simbÃ³lica. Es un lenguaje declarativo y funcional, orientado a la investigaciÃ³n

Al igual que Pascal, es un lenguaje de tipado estÃ¡tico. No obstante, se destacÃ³ por ser el primer lenguaje que contÃ³ con un sistema de inferencia de tipos. Es decir, no es obligatorio declarar el tipo de dato de una variable. A continuaciÃ³n un ejemplo del algoritmoÂ [insertion sort](https://platzi.com/clases/1775-poo-python/25266-ordenamiento-por-insercion/)Â en ML.  
![Insertion sort en Meta Languaje](https://static.platzi.com/media/articlases/Images/2022-04-28%20%287%29.png)

## Prolog

**Prolog**Â es un lenguaje de programaciÃ³n lÃ³gica. Ideado a principios de los aÃ±os 70 en la Universidad de Aix-Marseille I (Marsella, Francia) por Alain Colmerauer y Philippe Roussel, estÃ¡ basado en lasÂ **clÃ¡usulas de Horn**. Se mantiene vigente a dÃ­a de hoy, ya que se usa en el campo de la Inteligencia artificial y el procesamiento natural del lenguaje (NLP). Como dato curioso, el primer intÃ©rprete de Prolog fue desarrollado en FORTRAN.

He aquÃ­ un ejemplo de Prolog (el cual vimos en clases pasadas).

```prolog
speaks(juan, french)
speaks(isabel, english)
speaks(eduadro, french)
speaks(eduardo, english)

talkswith(Person1, Person2) :-
speaks(Person1, L),
speaks(Person2, L),
Person1 \= Person2

?- speaks(Who, French)
```

---
# DÃ©cada de los 80: Computadoras personales, POO (programaciÃ³n orientada a objetos), C++, Python
En la dÃ©cada de los 80 aparece la computadora personal, eliminando la necesidad de ir a institutos de investigaciÃ³n ni universidades para acceder a una computadora. Por la popularidad de los dispositivos, los lenguajes se empiezan orientar a la interfaz grÃ¡fica, cambiando el paradigma. En esta dÃ©cada aparecieron lenguajes destacados como C++ y Python.

## C++

**C++**Â se creÃ³ en 1986 definido por Bjarne Stroustrup como parte de una extensiÃ³n de C. Se dice que todo programa vÃ¡lido en C es tambiÃ©n un programa vÃ¡lido enÂ [C++](https://platzi.com/cursos/c-plus-plus/). Se destacÃ³ por incorporar el uso de clases, mejorar el sistema de tipado, implementar templates manipular objetos de forma directa y mejorar el sistema de herencia. AquÃ­ un ejemplo de cÃ³mo calcular el factorial en C++.

![Factorial en C++](https://static.platzi.com/media/articlases/Images/2022-04-28%20%288%29.png)

## Python

**Python**Â es un lenguaje creado Guido van Rossum a finales de los 80. Es interpretado, de alto nivel, multiparadigma y de propÃ³sito general. Tiene librerÃ­as para procesamiento matemÃ¡tico, asincronismo, inteligencia artificial, anÃ¡lisis de datos, etc. Tiene un gran rango de aplicaciones como el desarrollo web, IoT, mÃ³viles, videojuegos, servidores, IA y Ciencia de Datos.

Cabe destacar queÂ [Python](https://platzi.com/cursos/python/)Â tiene una filosofÃ­a de desarrollo conocida como elÂ **Zen de Python**, que busca hacer el cÃ³digo mÃ¡s legible. Los postulados de este zen son:

- Bello es mejor que feo
- ExplÃ­cito es mejor que implÃ­cito
- Simple es mejor que complejo
- Complejo es mejor que complicado
- La legibilidad cuenta

Como es costumbre, aquÃ­ te dejo un ejemplo de cÃ³mo se calcula el factorial en Python.

![Factorial en Python](https://static.platzi.com/media/articlases/Images/2022-04-28%20%289%29.png)

ğŸÂ **Python**Â es unÂ **lenguaje de programaciÃ³n**Â **basado**Â enÂ **LISP**Â yÂ **C**.

---
# DÃ©cada de los 90: Desarrollo web, Java, JavaScript
En los 90 surgieron innovaciones que permitieron la comunicaciÃ³n entre computadoras muy lejanas entre sÃ­: el navegador, el Internet y la web. A partir de estas invenciones surgieron lenguajes enfocados a la web, como Ruby, PHP,Â **Java**Â yÂ **JavaScript**. Hablemos mÃ¡s en profundidad sobre estos Ãºltimos.

## Java

Desarrollado por el green team dirigido por Jim Goslin en Sun Microsystems en 1990,Â **Java**Â es uno de los lenguajes mÃ¡s populares incluso en la actualidad. Su objetivo era ser utilizado en dispositivos de poder limitado conectados en una red.

DespuÃ©s se vio el potencial de Java en la web utilizando â€œappletsâ€. Estas se caracterizaban por ser seguras y portables (sin embargo, te pedÃ­an instalar Java)

Una de las caracterÃ­sticas deÂ [Java](https://platzi.com/cursos/java-basico/)Â es el uso de laÂ [**_Java Virtual Machine (JVM)_**](https://platzi.com/clases/2245-kotlin/36586-que-es-la-java-virtual-machine/). En Java el cÃ³digo se compila a bytecode, que despuÃ©s es interpretado por laÂ **JVM**. Cabe destacar que la JVM fue incorporada al navegador Netscape en 1995.

### Seguridad, otras caracterÃ­sticas y ejemplos

Java no genera errores de ejecuciÃ³n no detectados. AdemÃ¡s, Java realiza la verificaciÃ³n de tipos durante la compilaciÃ³nÂ **Y**Â la interpretaciÃ³n del bytecode.

Otras caracterÃ­sticas del lenguaje son:

- Simplicidad del lenguaje
- Garbage Collector
- Manejo implÃ­cito de punteros
- Uso de hilos para concurrencia

A continuaciÃ³n vemos un â€œhola mundoâ€ en Java.

```java
// JAVA
// Hola, mundo!
public class HelloWorldApp {
    public static void main(String[] args) {
        System.out.println("Hello World!");
     }
}
```

AdemÃ¡s de cÃ³mo calcular el factorial en Java.

```java
// JAVA
// Factorial de n
public double factorial (double numero) {
    if (numero == 0)
        return 1;
    else
        return numero * factorial(numero-1);
}
```

## JavaScript

[**JavaScript**](https://platzi.com/cursos/basico-javascript/)Â es un lenguaje multiparadigma de alto nivel, compiladoÂ **â€œjust-in-timeâ€**Â (se compila a medida que se ejecuta). Es dÃ©bilmente tipado y dinÃ¡mico, es decir, no se debe especificar los tipos de las variables, y estos pueden cambiar. EstÃ¡ basado enÂ [prototipos](https://platzi.com/clases/1642-javascript-profesional/22164-prototype/).

Se usa del lado del cliente y del servidor. En 2012 se volviÃ³ un estÃ¡ndar y es soportado por todos los navegadores por defecto.

Esto es un â€œhola mundoâ€ en JavaScript.

```javascript
console.log("hola mundo")
```

Y asÃ­ se puede calcular el factorial (de 3) en JavaScript

```javascript
function factorial(n) {
    if (n === 0)
        return 1;
    return n * factorial(n - 1);
}
factorial(3);
```

![[Pasted image 20231213185019.png]]

## Â¿Por quÃ© se llama JavaScript?
---
Brendan Eich, un programador que trabajaba en Netscape, pensÃ³ que podrÃ­a solucionar este problema adaptando otras tecnologÃ­as existentes (como ScriptEase) al navegador Netscape Navigator 2.0, que iba a lanzarse en 1995. Inicialmente, Eich denominÃ³ a su lenguaje LiveScript.  
ğŸ§‘ğŸ»â€ğŸ’»  
Posteriormente, Netscape firmÃ³ una alianza con Sun Microsystems para el desarrollo del nuevo lenguaje de programaciÃ³n. AdemÃ¡s, justo antes del lanzamiento Netscape decidiÃ³ cambiar el nombre por el de JavaScript. La razÃ³n del cambio de nombre fue exclusivamente por marketing, ya que Java era la palabra de moda en el mundo informÃ¡tico y de Internet de la Ã©poca.  
ğŸ–¥ï¸  
MÃ¡s infoÂ [aquÃ­](https://uniwebsidad.com/libros/javascript/capitulo-1/breve-historia)
